Ο Timer1 ρυθμίζεται να προκαλεί overflow κάθε 1sec (λειτουργία Fast PWM με clk/1024). Ο ADC ρυθμίζεται να ξεκινά μια μετατροπή κάθε φορά που συμβαίνει Timer1 overflow. Επίσης ο ADC ρυθμίζεται να διαβάζει από την είσοδο Α2 (που αντιστοιχεί στο POT3), να προκαλεί διακοπή όταν ολοκληρώσει την μετατροπή και να έχει για τάση αναφοράς την Vref=5V.

Η οθόνη αρχικοποιείται σύμφωνα με την δοθείσα ρουτίνα lcd_init.

Στην ρουτίνα εξυπηρέτησης διακοπής, διαβάζουμε την τιμή που μέτρησε ο ADC και έπειτα βρίσκουμε τα 3 δεκαδικά ψηφία (x.yz) της Vin = ADC * Vref/1024. Αυτό επιτυγχάνεται υπολογίζοντας αρχικά:
A = ADC * Vref = ADC * 5 = ADC<<2 + ADC
Τότε (παρακάτω οι διαιρέσεις νοούνται ως ακέραιες διαιρέσεις):
x = ADC * Vref/1024 = A / 2^10 = Α >> 10

Έπειτα είναι y = ((A - 1024*x) * 10) / 1024 = ((A - (A>>10)<<10) * 10) / 1024 = ((A & 0x3FF) * 10) / 1024 = ((A & 0x3FF) * 10) << 10.
Όμοια αν αφαιρέσουμε πάλι το ακέραιο μέρος y και πολλαπλάσιουμε με το 10, λαμβάνουμε:
Αν Β = (Α & 0χ3FF) * 10 (υπολογισμένο από πριν) είναι όμοια:
z = ((B & 0x3FF) * 10) << 10.

Τέλος ένας αποδοτικός τρόπος για τον υπολογισμό του 10*x είναι ο εξής: 10*x = 8*x+2*x = x<<3 + x

Επειδή ο παραπάνω υπολογισμός είναι κάπως δύσκολο να επιβεβαιώσει κανείς ότι συντάχθηκε σωστά σε AVR Assembly προσομοιώσαμε την AVR Assembly σε Python instruction προς instruction. Σε 1000000 τυχαιοποιημένες μετατροπές η μετατροπή συνέβαινε σωστά.

Τέλος για την μετατροπή των x,y,z σε ASCII χαρακτηρές τους προσθέσαμε τον ASCII κωδικό του '0'=48.
