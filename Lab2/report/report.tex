\documentclass[a4paper]{article}
\usepackage[margin=2cm]{geometry}

\usepackage{xgreek}
\usepackage{xltxtra}
\usepackage{unicode-math}
\usepackage{graphicx}
\usepackage{float}
%\usepackage{tocbibind}
\usepackage[pdfusetitle]{hyperref}
\graphicspath{{./images/}}
\setmainfont[Mapping=tex-text]{CMU Serif}
\setsansfont[Mapping=tex-text]{CMU Sans Serif}
\setmonofont{CMU Typewriter Text}
\usepackage{minted}

\title{2η Εργαστηριακή Άσκηση\\Εργαστήριο Μικροϋπολογιστών}
\author{Ανδρέας Στάμος (03120018), Κωνσταντίνος Πίκουλας (03120112)}
\date{Οκτώβριος 2023}

\hypersetup{
colorlinks=true,
linkcolor=blue,
}

\begin{document}


\maketitle
\tableofcontents

\section{Ζήτημα 2.1}
Οι διακοπές ρυθμίστηκαν στην ανερχόμενη ακμή (την στιγμή δηλαδή που αφήνουμε το κουμπί). Στην ρουτίνα εξυπηρέτησης διακοπής
γίνεται ελέγχος αν το PD6 είναι πατημένο, και αν είναι απλά επιστρέφει χωρίς να κάνει κάτι. Προκειμένου να αποφύγουμε την πρόκληση πολλαπλών
διακοπών λόγω σπινθηρισμών, κάναμε debounce την ρουτίνα εξυπηρέτησης διακοπών, εκτελώντας την διακοπή, μόνο αν στα τελευταία 5ms δεν συνέβη νέα
διακοπή. Ο μετρητής των διακοπών αποθηκεύεται στον \texttt{r19} που χρησιμοποιείται αποκλειστικά από την ρουτίνα εξυπηρέτησης διακοπής, οπότε
ενδιάμεσα στις διακοπές δεν απαιτείται να αποθηκεύεται στην μνήμη.

Ο κώδικας Assembly είναι ο παρακάτω:
\inputminted[breaklines, linenos]{gas}{../Lab2.1/main_k.asm}


\section{Ζήτημα 2.2}
\par Οι διακοπές ρυθμίστηκαν στην αρνητική στάθμη τάσης (δηλαδή για όσο πατάμε το κουμπί). Ο λόγος είναι πως επιθυμούμε στην ρουτίνα εξυπηρέτησης
διακοπής να μπορούμε να ανιχνεύουμε αν το κουμπί παραμένει πατημένο, προκειμένου να παραμένουμε στην ρουτίνα εξυπηρέτησης διακοπής.
Λόγω σπινθηρισμών, αν απλά κάναμε poll το \texttt{PIND}, σύντομα θα το βρίσκαμε λανθασμένα πως δεν είναι πατημένο και θα επιστρέφαμε από την διακοπή.
Αντίθεα, με ρυθμισμένη την διακοπή στο αρνητικό επιπέδο, απλά ανιχνεύουμε αν σε ένα διάστημα 5 ms συνέβη διακοπή, μηδενίζοντας στον \texttt{EIFR}
την \texttt{INT0}, περιμένοντας 5 ms και έπειτα ελέγχοντας στον \texttt{EIFR} αν συνέβη \texttt{INT0}.

\par Επειδή οι ενδείξεις της ``κανονικής λειτουργίας'' (την μέτρηση) και της ``λετουργίας της διακοπής'' είναι στο ίδιο PORT,
μέσα στην διακοπή, αποθηκεύουμε πρώτα τι προϋπήρχε στο \texttt{PORTC} και πριν επιστρέψουμε, το ξαναθέτουμε στο \texttt{PORTC}.

\par Η ζητούμενη λειτουργία (ενεργοποίηση τόσων LSB LEDS στο \texttt{PORTC} όσα κουμπιά έχουν πατηθεί στα \texttt{PB0-PB4}) υλοποιείται
ελέγχοντας ένα-ένα τα bits του \texttt{PINB} (με χρήση της \texttt{sbis}) και αν έχουν τιμή 0, τότε κάνουμε αριστερό shift την τιμή του
τρέχοντος αποτελέσματος και bitwise OR με το 0x1 (προσθέτουμε έναν ακόμα LSB άσσο).

Ο κώδικας Assembly είναι ο παρακάτω:
\inputminted[breaklines, linenos]{gas}{../Lab2.2/main.asm}


\section{Ζήτημα 2.3}

\par Αρχικά σκεφτήκαμε στις ανανεώσεις να προκαλούμε nested διακοπές που μετρούν τον νέο χρόνο και, έπειτα, μηδενίζοντας τον μετρητή
\texttt{r25:r24} πρακτικά θα μηδενιζόταν ο χρόνος της γονικής διακοπής, οπότε εκείνη θα τερμάτιζε. Παρατηρήσαμε ότι αυτό δεν συνέβαινε.
Ο λόγος που δεν συνέβαινε είναι πως με τον μηδενισμό του μετρήτη, ανάλογα που είχε συμβεί η διακοπή-παιδί στην γονική διακοπή, τύχαινε το εξής
(κάπως σαν race condition):

\par Η διακοπή-παιδί μηδένιζε τον μετρητή \texttt{r25:r24}. Στην γονική διακοπή αφαιρούνταν 1 από τον μετρητή και έπειτα γινόταν ο ελέγχος
αν ο μετρητής μηδένισε. Επειδή ο μετρητής είχε μηδενίσει με την αφαίρεση, πήγαινε στο \texttt{0xFFFF} που σημαίνει ότι είχε ακόμα να περιμένει αντί
μηδενικού χρόνου,
$\mathtt{0 \text{x} FFFF} \cdot 1000\ \text{κύκλους}\ \cdot \frac{1}{16\ \text{MHz}} \approx 4\ \text{sec}$.

\par Το πρόβλημα το ανιμετωπίσαμε, ανανεώνοντας απλά τον χρόνο που πρέπει να τρέξει η γονική διακοπή αντί να προσπαθήσουμε
να την ακυρώσουμε (στην αρχή γράψαμε μια λύση όπου ακυρώναμε την γονική διακοπή αφαιρώντας το frame της από την stack, όμως αυτό
γενικά δεν είναι καλή προγραμματιστική ιδέα).
\par Έτσι αν είμαστε στο στάδιο όπου είναι αναμένo το 1 LED, τα ανάβουμε όλα για 500ms και έπειτα αλλάζουμε τον μετρητή της γονικής σε 2500ms,
ενώ αν είμαστε στο στάδιο όπου είναι αναμένα όλα τα LEDs, απλά ανανεώνουμε τον χρόνο των όλων LEds σε 500ms.
\par Επιπρόσθετα, προκειμένου να αποφύγουμε τυχόντα άλλα race conditions και προκειμένου να εξασφαλίσουμε την ορθότητα του προγράμματος,
επιτρέψαμε τις διακοπές μόνο μέσα στην delay. (εξάλλου σύμφωνα με το datasheet του ATMega328PB η διακοπή αποθηκεύεται ότι συνέβη στον \texttt{EIFR}
με την ρουτίνα εξυπηρέτησης διακοπής να εκτελείται μόλις στον \texttt{SREG} το Interrupts flag γίνει ενεργό.)
\par Στον κώδικα C ακολουθήσαμε παρόμοια λογική, όμως προκειμένου να χρησιμοποιήσουμε την έτοιμη ρουτίνα \texttt{\_delay\_ms},
χωρίσαμε τα χρονικά διαστήματα αναμονής σε διαστήματα του 1 ms και διατηρήσαμε μετρητή για το πόσα διαστήματα του 1 ms πρέπει να γίνουν.
Επιπρόσθετα στην κατάσταση που όλα τα LEDs ήταν αναμένα, καταφέραμε να επιτυχούμε τον αρχικό στόχο μας να ``ακυρώνουμε'' την delay της γονικής
διακοπής με τον μηδενισμό του αντίστοιχου μετρητή, επιβάλλοντας την ατομικότητα (απενεργοποιώντας και ενεργοποιώντας τις διακοπές) του τμήματος
όπου πρώτα ελέγχουμε αν είναι θετικός ο μετρητής και έπειτα τον μειώνουμε κατά 1.

Ο κώδικας Assembly είναι ο παρακάτω:
\inputminted[breaklines, linenos]{gas}{../Lab2.3/main_k.asm}

Ο κώδικας C είναι ο παρακάτω:
\inputminted[breaklines, linenos]{c}{../Lab2.3/main_k.c}

\end{document}

